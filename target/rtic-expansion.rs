# [doc = r" The RTIC application module"] pub mod app {# [doc = r" Always include the device crate which contains the vector table"] use stm32f3xx_hal :: pac as you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml ; # [doc = r" Holds the maximum priority level for use by async HAL drivers."] # [no_mangle] static RTIC_ASYNC_MAX_LOGICAL_PRIO : u8 = 1 << stm32f3xx_hal :: pac :: NVIC_PRIO_BITS ; use super :: * ; # [doc = r" User code end"] struct Shared {frequency_index : u32 , delay : Delay ,} struct Local {led : PE8 < Output < PushPull > > , state : bool , signal : PwmChannel < Tim3Ch1 , WithPins > , trig : Pin < Gpiob , U < 9 > , Output < PushPull > > , echo : Pin < Gpiob , U < 8 > , Input > , timer : MonoTimer ,} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_init_Context < 'a > {# [doc (hidden)] __rtic_internal_p : :: core :: marker :: PhantomData < & 'a () > , # [doc = r" Core peripherals"] pub core : rtic :: export :: Peripherals , # [doc = r" Device peripherals (PAC)"] pub device : stm32f3xx_hal :: pac :: Peripherals , # [doc = r" Critical section token for init"] pub cs : rtic :: export :: CriticalSection < 'a > ,} impl < 'a > __rtic_internal_init_Context < 'a > {# [inline (always)] # [allow (missing_docs)] pub unsafe fn new (core : rtic :: export :: Peripherals ,) -> Self {__rtic_internal_init_Context {__rtic_internal_p : :: core :: marker :: PhantomData , device : stm32f3xx_hal :: pac :: Peripherals :: steal () , cs : rtic :: export :: CriticalSection :: new () , core ,}}} # [allow (non_snake_case)] # [doc = "Initialization function"] pub mod init {# [doc (inline)] pub use super :: __rtic_internal_init_Context as Context ;} # [inline (always)] # [allow (non_snake_case)] fn init (cx : init :: Context) -> (Shared , Local) {let mut flash = cx . device . FLASH . constrain () ; let mut rcc = cx . device . RCC . constrain () ; defmt :: info ! ("init") ; let _clocks = rcc . cfgr . use_hse (8 . MHz ()) . sysclk (36 . MHz ()) . pclk1 (36 . MHz ()) . freeze (& mut flash . acr) ; let delay = Delay :: new (cx . core . SYST , _clocks) ; let mut DCB = cx . core . DCB ; let mut timer = MonoTimer :: new (cx . core . DWT , _clocks , & mut DCB) ; let mut gpioe = cx . device . GPIOE . split (& mut rcc . ahb) ; let mut led = gpioe . pe8 . into_push_pull_output (& mut gpioe . moder , & mut gpioe . otyper) ; led . set_high () . unwrap () ; let mut gpiob = cx . device . GPIOB . split (& mut rcc . ahb) ; let pb4 = gpiob . pb4 . into_af_push_pull (& mut gpiob . moder , & mut gpiob . otyper , & mut gpiob . afrl) ; let tim3_channels = tim3 (cx . device . TIM3 , 9000 , 100 . Hz () , & _clocks) ; let mut signal : PwmChannel < Tim3Ch1 , WithPins > = tim3_channels . 0 . output_to_pb4 (pb4) ; signal . enable () ; signal . set_duty (signal . get_max_duty () / 2) ; let mut echo = gpiob . pb8 . into_pull_up_input (& mut gpiob . moder , & mut gpiob . pupdr) ; let mut trig = gpiob . pb9 . into_push_pull_output (& mut gpiob . moder , & mut gpiob . otyper) ; ultrasonic :: spawn () . ok () ; (Shared {frequency_index : 0 , delay ,} , Local {led , state : false , signal , trig , echo , timer ,} ,)} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_idle_Context < 'a > {# [doc (hidden)] __rtic_internal_p : :: core :: marker :: PhantomData < & 'a () > ,} impl < 'a > __rtic_internal_idle_Context < 'a > {# [inline (always)] # [allow (missing_docs)] pub unsafe fn new () -> Self {__rtic_internal_idle_Context {__rtic_internal_p : :: core :: marker :: PhantomData ,}}} # [allow (non_snake_case)] # [doc = "Idle loop"] pub mod idle {# [doc (inline)] pub use super :: __rtic_internal_idle_Context as Context ;} # [allow (non_snake_case)] fn idle (_ : idle :: Context) -> ! {use rtic :: Mutex as _ ; use rtic :: mutex :: prelude :: * ; defmt :: info ! ("idle") ; loop {ultrasonic :: spawn () ;}} impl < 'a > __rtic_internal_ultrasonicLocalResources < 'a > {# [inline (always)] # [allow (missing_docs)] pub unsafe fn new () -> Self {__rtic_internal_ultrasonicLocalResources {echo : & mut * (& mut * __rtic_internal_local_resource_echo . get_mut ()) . as_mut_ptr () , trig : & mut * (& mut * __rtic_internal_local_resource_trig . get_mut ()) . as_mut_ptr () , timer : & mut * (& mut * __rtic_internal_local_resource_timer . get_mut ()) . as_mut_ptr () , __rtic_internal_marker : :: core :: marker :: PhantomData ,}}} impl < 'a > __rtic_internal_ultrasonicSharedResources < 'a > {# [inline (always)] # [allow (missing_docs)] pub unsafe fn new () -> Self {__rtic_internal_ultrasonicSharedResources {delay : shared_resources :: delay_that_needs_to_be_locked :: new () , frequency_index : shared_resources :: frequency_index_that_needs_to_be_locked :: new () , __rtic_internal_marker : core :: marker :: PhantomData ,}}} impl < 'a > __rtic_internal_set_speakerLocalResources < 'a > {# [inline (always)] # [allow (missing_docs)] pub unsafe fn new () -> Self {__rtic_internal_set_speakerLocalResources {signal : & mut * (& mut * __rtic_internal_local_resource_signal . get_mut ()) . as_mut_ptr () , __rtic_internal_marker : :: core :: marker :: PhantomData ,}}} impl < 'a > __rtic_internal_set_speakerSharedResources < 'a > {# [inline (always)] # [allow (missing_docs)] pub unsafe fn new () -> Self {__rtic_internal_set_speakerSharedResources {delay : shared_resources :: delay_that_needs_to_be_locked :: new () , frequency_index : shared_resources :: frequency_index_that_needs_to_be_locked :: new () , __rtic_internal_marker : core :: marker :: PhantomData ,}}} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = "Local resources `ultrasonic` has access to"] pub struct __rtic_internal_ultrasonicLocalResources < 'a > {# [allow (missing_docs)] pub echo : & 'a mut Pin < Gpiob , U < 8 > , Input > , # [allow (missing_docs)] pub trig : & 'a mut Pin < Gpiob , U < 9 > , Output < PushPull > > , # [allow (missing_docs)] pub timer : & 'a mut MonoTimer , # [doc (hidden)] pub __rtic_internal_marker : :: core :: marker :: PhantomData < & 'a () > ,} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = "Shared resources `ultrasonic` has access to"] pub struct __rtic_internal_ultrasonicSharedResources < 'a > {# [allow (missing_docs)] pub delay : shared_resources :: delay_that_needs_to_be_locked < 'a > , # [allow (missing_docs)] pub frequency_index : shared_resources :: frequency_index_that_needs_to_be_locked < 'a > , # [doc (hidden)] pub __rtic_internal_marker : core :: marker :: PhantomData < & 'a () > ,} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_ultrasonic_Context < 'a > {# [doc (hidden)] __rtic_internal_p : :: core :: marker :: PhantomData < & 'a () > , # [doc = r" Local Resources this task has access to"] pub local : ultrasonic :: LocalResources < 'a > , # [doc = r" Shared Resources this task has access to"] pub shared : ultrasonic :: SharedResources < 'a > ,} impl < 'a > __rtic_internal_ultrasonic_Context < 'a > {# [inline (always)] # [allow (missing_docs)] pub unsafe fn new () -> Self {__rtic_internal_ultrasonic_Context {__rtic_internal_p : :: core :: marker :: PhantomData , local : ultrasonic :: LocalResources :: new () , shared : ultrasonic :: SharedResources :: new () ,}}} # [doc = r" Spawns the task directly"] # [allow (non_snake_case)] # [doc (hidden)] pub fn __rtic_internal_ultrasonic_spawn () -> Result < () , () > {unsafe {if __rtic_internal_ultrasonic_EXEC . try_allocate () {let f = ultrasonic (unsafe {ultrasonic :: Context :: new ()}) ; __rtic_internal_ultrasonic_EXEC . spawn (f) ; rtic :: export :: pend (stm32f3xx_hal :: pac :: interrupt :: SPI1) ; Ok (())} else {Err (())}}} # [allow (non_snake_case)] # [doc = "Software task"] pub mod ultrasonic {# [doc (inline)] pub use super :: __rtic_internal_ultrasonicLocalResources as LocalResources ; # [doc (inline)] pub use super :: __rtic_internal_ultrasonicSharedResources as SharedResources ; # [doc (inline)] pub use super :: __rtic_internal_ultrasonic_Context as Context ; # [doc (inline)] pub use super :: __rtic_internal_ultrasonic_spawn as spawn ;} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = "Local resources `set_speaker` has access to"] pub struct __rtic_internal_set_speakerLocalResources < 'a > {# [allow (missing_docs)] pub signal : & 'a mut PwmChannel < Tim3Ch1 , WithPins > , # [doc (hidden)] pub __rtic_internal_marker : :: core :: marker :: PhantomData < & 'a () > ,} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = "Shared resources `set_speaker` has access to"] pub struct __rtic_internal_set_speakerSharedResources < 'a > {# [allow (missing_docs)] pub delay : shared_resources :: delay_that_needs_to_be_locked < 'a > , # [allow (missing_docs)] pub frequency_index : shared_resources :: frequency_index_that_needs_to_be_locked < 'a > , # [doc (hidden)] pub __rtic_internal_marker : core :: marker :: PhantomData < & 'a () > ,} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_set_speaker_Context < 'a > {# [doc (hidden)] __rtic_internal_p : :: core :: marker :: PhantomData < & 'a () > , # [doc = r" Local Resources this task has access to"] pub local : set_speaker :: LocalResources < 'a > , # [doc = r" Shared Resources this task has access to"] pub shared : set_speaker :: SharedResources < 'a > ,} impl < 'a > __rtic_internal_set_speaker_Context < 'a > {# [inline (always)] # [allow (missing_docs)] pub unsafe fn new () -> Self {__rtic_internal_set_speaker_Context {__rtic_internal_p : :: core :: marker :: PhantomData , local : set_speaker :: LocalResources :: new () , shared : set_speaker :: SharedResources :: new () ,}}} # [doc = r" Spawns the task directly"] # [allow (non_snake_case)] # [doc (hidden)] pub fn __rtic_internal_set_speaker_spawn () -> Result < () , () > {unsafe {if __rtic_internal_set_speaker_EXEC . try_allocate () {let f = set_speaker (unsafe {set_speaker :: Context :: new ()}) ; __rtic_internal_set_speaker_EXEC . spawn (f) ; rtic :: export :: pend (stm32f3xx_hal :: pac :: interrupt :: SPI1) ; Ok (())} else {Err (())}}} # [allow (non_snake_case)] # [doc = "Software task"] pub mod set_speaker {# [doc (inline)] pub use super :: __rtic_internal_set_speakerLocalResources as LocalResources ; # [doc (inline)] pub use super :: __rtic_internal_set_speakerSharedResources as SharedResources ; # [doc (inline)] pub use super :: __rtic_internal_set_speaker_Context as Context ; # [doc (inline)] pub use super :: __rtic_internal_set_speaker_spawn as spawn ;} # [allow (non_snake_case)] async fn ultrasonic < 'a > (mut cx : ultrasonic :: Context < 'a >) {use rtic :: Mutex as _ ; use rtic :: mutex :: prelude :: * ; let mut delay = cx . shared . delay ; defmt :: info ! ("ultrasonic reading") ; cx . local . trig . set_low () . unwrap () ; delay . lock (| delay | {delay . delay_us (10_u32) ;}) ; cx . local . trig . set_high () . unwrap () ; delay . lock (| delay | {delay . delay_us (5_u32) ;}) ; cx . local . trig . set_low () . unwrap () ; defmt :: info ! ("waiting for echo") ; while ! cx . local . echo . is_high () . unwrap () {} ; defmt :: info ! ("echo received, starting timer") ; let start = cx . local . timer . now () ; while ! cx . local . echo . is_low () . unwrap () {} ; defmt :: info ! ("echo finished") ; let duration = start . elapsed () ; let distance = duration / 2 / 29 / 10 ; defmt :: info ! ("Distance {}" , distance) ; let distance_index = match distance {0 ..= 50 => 1 , 51 ..= 100 => 2 , 101 ..= 150 => 3 , _ => 4 ,} ; cx . shared . frequency_index . lock (| frequency_index | {* frequency_index = distance_index ;}) ; set_speaker :: spawn () . ok () ;} # [allow (non_snake_case)] async fn set_speaker < 'a > (mut cx : set_speaker :: Context < 'a >) {use rtic :: Mutex as _ ; use rtic :: mutex :: prelude :: * ; let mut delay = cx . shared . delay ; let key = cx . shared . frequency_index . lock (| frequency_index | * frequency_index) ; defmt :: info ! ("Setting speaker | Key: {}" , key) ; let (freq , period) = match key {1 => (250 , 125_u32) , 2 => (100 , 250_u32) , 3 => (100 , 500_u32) , 4 => (100 , 1000_u32) , _ => (100 , 600_u32) ,} ; cx . local . signal . disable () ; unsafe {(* pac :: TIM3 :: ptr ()) . psc . write (| w | w . bits (80_000 / freq)) ; (* pac :: TIM3 :: ptr ()) . arr . write (| w | w . bits (100)) ;} ; delay . lock (| delay | {delay . delay_ms (10_u32) ;}) ; cx . local . signal . enable () ; cx . local . signal . set_duty (cx . local . signal . get_max_duty () / 2) ; defmt :: info ! ("Period: {}" , period) ; delay . lock (| delay | {delay . delay_ms (period) ;}) ; defmt :: info ! ("Checkpoint") ; cx . local . signal . disable () ;} # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic0"] static __rtic_internal_shared_resource_frequency_index : rtic :: RacyCell < core :: mem :: MaybeUninit < u32 >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; impl < 'a > rtic :: Mutex for shared_resources :: frequency_index_that_needs_to_be_locked < 'a > {type T = u32 ; # [inline (always)] fn lock < RTIC_INTERNAL_R > (& mut self , f : impl FnOnce (& mut u32) -> RTIC_INTERNAL_R) -> RTIC_INTERNAL_R {# [doc = r" Priority ceiling"] const CEILING : u8 = 1u8 ; unsafe {rtic :: export :: lock (__rtic_internal_shared_resource_frequency_index . get_mut () as * mut _ , CEILING , stm32f3xx_hal :: pac :: NVIC_PRIO_BITS , f ,)}}} # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic1"] static __rtic_internal_shared_resource_delay : rtic :: RacyCell < core :: mem :: MaybeUninit < Delay >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; impl < 'a > rtic :: Mutex for shared_resources :: delay_that_needs_to_be_locked < 'a > {type T = Delay ; # [inline (always)] fn lock < RTIC_INTERNAL_R > (& mut self , f : impl FnOnce (& mut Delay) -> RTIC_INTERNAL_R) -> RTIC_INTERNAL_R {# [doc = r" Priority ceiling"] const CEILING : u8 = 1u8 ; unsafe {rtic :: export :: lock (__rtic_internal_shared_resource_delay . get_mut () as * mut _ , CEILING , stm32f3xx_hal :: pac :: NVIC_PRIO_BITS , f ,)}}} mod shared_resources {# [doc (hidden)] # [allow (non_camel_case_types)] pub struct frequency_index_that_needs_to_be_locked < 'a > {__rtic_internal_p : :: core :: marker :: PhantomData < & 'a () > ,} impl < 'a > frequency_index_that_needs_to_be_locked < 'a > {# [inline (always)] pub unsafe fn new () -> Self {frequency_index_that_needs_to_be_locked {__rtic_internal_p : :: core :: marker :: PhantomData}}} # [doc (hidden)] # [allow (non_camel_case_types)] pub struct delay_that_needs_to_be_locked < 'a > {__rtic_internal_p : :: core :: marker :: PhantomData < & 'a () > ,} impl < 'a > delay_that_needs_to_be_locked < 'a > {# [inline (always)] pub unsafe fn new () -> Self {delay_that_needs_to_be_locked {__rtic_internal_p : :: core :: marker :: PhantomData}}}} # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic2"] static __rtic_internal_local_resource_led : rtic :: RacyCell < core :: mem :: MaybeUninit < PE8 < Output < PushPull > > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic3"] static __rtic_internal_local_resource_state : rtic :: RacyCell < core :: mem :: MaybeUninit < bool >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic4"] static __rtic_internal_local_resource_signal : rtic :: RacyCell < core :: mem :: MaybeUninit < PwmChannel < Tim3Ch1 , WithPins > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic5"] static __rtic_internal_local_resource_trig : rtic :: RacyCell < core :: mem :: MaybeUninit < Pin < Gpiob , U < 9 > , Output < PushPull > > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic6"] static __rtic_internal_local_resource_echo : rtic :: RacyCell < core :: mem :: MaybeUninit < Pin < Gpiob , U < 8 > , Input > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic7"] static __rtic_internal_local_resource_timer : rtic :: RacyCell < core :: mem :: MaybeUninit < MonoTimer >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] type __rtic_internal_ultrasonic_F = impl core :: future :: Future ; # [allow (non_upper_case_globals)] static __rtic_internal_ultrasonic_EXEC : rtic :: export :: executor :: AsyncTaskExecutor < __rtic_internal_ultrasonic_F > = rtic :: export :: executor :: AsyncTaskExecutor :: new () ; # [allow (non_camel_case_types)] type __rtic_internal_set_speaker_F = impl core :: future :: Future ; # [allow (non_upper_case_globals)] static __rtic_internal_set_speaker_EXEC : rtic :: export :: executor :: AsyncTaskExecutor < __rtic_internal_set_speaker_F > = rtic :: export :: executor :: AsyncTaskExecutor :: new () ; # [allow (non_snake_case)] # [doc = "Interrupt handler to dispatch async tasks at priority 1"] # [no_mangle] unsafe fn SPI1 () {# [doc = r" The priority of this interrupt handler"] const PRIORITY : u8 = 1u8 ; rtic :: export :: run (PRIORITY , || {__rtic_internal_set_speaker_EXEC . poll (|| {__rtic_internal_set_speaker_EXEC . set_pending () ; rtic :: export :: pend (stm32f3xx_hal :: pac :: interrupt :: SPI1) ;}) ; __rtic_internal_ultrasonic_EXEC . poll (|| {__rtic_internal_ultrasonic_EXEC . set_pending () ; rtic :: export :: pend (stm32f3xx_hal :: pac :: interrupt :: SPI1) ;}) ;}) ;} # [doc (hidden)] # [no_mangle] unsafe extern "C" fn main () -> ! {rtic :: export :: assert_send :: < u32 > () ; rtic :: export :: assert_send :: < Delay > () ; rtic :: export :: interrupt :: disable () ; let mut core : rtic :: export :: Peripherals = rtic :: export :: Peripherals :: steal () . into () ; let _ = you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: SPI1 ; const _ : () = if (1 << stm32f3xx_hal :: pac :: NVIC_PRIO_BITS) < 1u8 as usize {:: core :: panic ! ("Maximum priority used by interrupt vector 'SPI1' is more than supported by hardware") ;} ; core . NVIC . set_priority (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: SPI1 , rtic :: export :: cortex_logical2hw (1u8 , stm32f3xx_hal :: pac :: NVIC_PRIO_BITS) ,) ; rtic :: export :: NVIC :: unmask (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: SPI1) ; # [inline (never)] fn __rtic_init_resources < F > (f : F) where F : FnOnce () {f () ;} __rtic_init_resources (|| {let (shared_resources , local_resources) = init (init :: Context :: new (core . into ())) ; __rtic_internal_shared_resource_frequency_index . get_mut () . write (core :: mem :: MaybeUninit :: new (shared_resources . frequency_index)) ; __rtic_internal_shared_resource_delay . get_mut () . write (core :: mem :: MaybeUninit :: new (shared_resources . delay)) ; __rtic_internal_local_resource_signal . get_mut () . write (core :: mem :: MaybeUninit :: new (local_resources . signal)) ; __rtic_internal_local_resource_trig . get_mut () . write (core :: mem :: MaybeUninit :: new (local_resources . trig)) ; __rtic_internal_local_resource_echo . get_mut () . write (core :: mem :: MaybeUninit :: new (local_resources . echo)) ; __rtic_internal_local_resource_timer . get_mut () . write (core :: mem :: MaybeUninit :: new (local_resources . timer)) ; rtic :: export :: interrupt :: enable () ;}) ; idle (idle :: Context :: new ())}}